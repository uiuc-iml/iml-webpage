
<style>
#nav {
	width: 100%;
	margin: 0;
	padding: 0;
	list-style: none; 
        text-align:center;
	}
#nav li { margin:0; margin-bottom:1em; }
#nav li a {
	display:block;
	font-size:120%;
	width:100%;
	padding: 8px 15px;
	text-decoration: none;
	font-weight: bold;
	color: #000;
	background-color:#fbd5d6;
	border:1px solid #7c2237;
   -moz-box-sizing:    border-box;
   -webkit-box-sizing: border-box;
    box-sizing:        border-box;
	box-shadow: 2px 2px 3px #ccc;
}
#nav li a:hover {
	color:#996667;
	background-color: #fff; }

ul li p { font-size: 100%; }


.subheading {
   font-style:italic;
}
div.subheading {
   font-size:80%;
}
div.video {
   text-align:center;
   margin-right:20px;
   display:inline-block;
   width:420px;
}

a.Q {
	font-size:110%;
	font-weight:bold;
	font-style:normal; 
}
a.Q:hover {
     color:#996667;
}
.touch a.Q {
	font-weight:bold; color:#4d3c43; font-style:normal;  	border:solid 1px #C2C2C2; background-color:#fff0f0;
}
div.A {
	font-size:120%;
	font-weight:normal;
	display:none;
	margin-top:-0.6em;
}
</style>

<script language="javascript" type="text/javascript">
function showHide(shID) {
   if (document.getElementById(shID)) {
      if (document.getElementById(shID).style.display != 'block') {
         document.getElementById(shID).style.display = 'block';
      }
      else {
         document.getElementById(shID).style.display = 'none';
      }
   }
}
</script>


<div style="display:table;">
<div style="display:table-cell; vertical-align:top; padding-right:2em; width:600px;">
<img src="klampt-image.jpg" alt="Kris' Locomotion and Manipulation Planning Toolbox (Klamp't)">
</div>

<div style="display:table-cell; vertical-align:top; position:relative; overflow:hidden; min-width:10em;">

<p>Klamp't is a cross-platform software package for modeling, simulating, planning, and optimization for complex robots, particularly for manipulation and locomotion tasks. It was first developed at Indiana University since 2009 primarily as a research platform, and has been used in classrooms beginning in 2013.  It has been used in several real-world projects, including the Amazon Picking Challenge, TeamHubo in the DARPA Robotics Challenge, and was the platform for the IROS 2016 Robot Grasping and Manipulation Challenge simulation track.
</p>

<div style="padding:1em;">
<ul id="nav">
	<li><a href="#features">Features</a></li>
	<li><a href="#media">Media</a></li>
	<li><a href="#install">Installation</a></li>
	<li><a href="#docs">Documentation</a></li>
	<li><a href="#faq">FAQ</a></li>
    <li><a href="https://github.com/krishauser/Klampt">Github Repo</a></li>
    <li><a href="https://gitq.com/krishauser/Klampt">Forum</a></li>
</ul>
</div>


</div>
</div>

<div class="separator"></div>

<a name="features"></a>
<h3>Features</h3>
<div class="subheading">Modeling</div>
<ul>
  <li>Supports legged and fixed-based robots.</li>
  <li>Supports URDF robot file format.</li>
  <li>Collision detection with meshes, point clouds, and voxel grids</li>
  <li>Forward and inverse kinematics, forward and inverse dynamics</li>
  <li>Contact mechanics computations: force closure, support polygons, stability of rigid bodies and actuated robots</li>
  <li>Keyframe poser and path editor</li>
  <li>Integration with PyTorch, Casadi, and Sympy</li>
</ul>
<div class="subheading">System Integration</div>
<ul>
  <li>Unified interface to simulated and physical robots.</li>
  <li>Smooth motion generation and Cartesian control plugins to add to your own robot's controllers.</li>
  <li>Extrinsic calibration tools.</li>
  <li>Workspace calculation tools.</li>
  <li>Comprehensive file I/O for visual browsing, editing, and programming with reusable assets (joint poses, trajectories, etc).</li>
</ul>
<div class="subheading">Simulation</div>
<ul>
	<li>Robust rigid body simulation with triangle mesh / triangle mesh collisions.</li>
	<li>Simulation of PID controlled, torque controlled, and velocity controlled motors.</li>
	<li>Simulation of various sensors including RGB+D cameras, laser sensors, gyroscopes, force/torque sensors, and accelerometers. </li>
	<li>ROS bindings are available for broadcasting simulation data and reading robot trajectory commands.</li>
</ul>
<div class="subheading">Planning</div>
<ul>
<li>Many sampling-based motion planners implemented.</li>
<li>Motion planning on constrained manifolds.</li>
<li>Fast trajectory optimization routines.</li>
<li>Real-time motion planning routines.</li>
<li>Planning models are fully decoupled from simulation models, which helps evaluate behavior under errors and uncertainty.</li>
</ul>

<p><span class="subheading">Current version</span>: 0.9.2</p>
<p><span class="subheading">Languages</span>: C++ and Python</p>
<p><span class="subheading">Supported platforms</span>: *nix environments, Windows, and Mac OSX. </p>

<div class="subheading">What's new?</div>
<p>Version 0.9.0 is a major update, with some API-breaking changes:</p>
<ul>
  <li>Python API: type hints are available throughout the SWIG interface and in many native Python functions.</li>
  <li>Python API: direct Numpy interface speeds up large data copies. Tests indicate ~6x speedup (45ms->7.5ms) for getting a simulated sensor image (SimRobotSensor.getMeasurements()), ~80x speedup (160ms->2ms) for converting images to point clouds (PointCloud.setDepthImage/setRGBDImages), and 20x speedup (200ms->10ms) for converting a Numpy array to a point cloud (tested on 640x480 images).</li>
  <li>Python API: major updates to the Klampt control package, including the new klampt_control utility that lets you control your robots in real time. (API-breaking change)</li>
  <li>Python API: standardization of robot semantic information under a RobotInfo class in klampt.model.robotinfo. Supported by klampt_control and klampt_sim. Future planners and system integration utilities will use this structure.</li>
  <li>Python API: klampt_resource script added which allows transfer and conversions of resources from the command line. klampt_thumbnails has been removed since all thumbnail functionality has been moved into klampt_resource.</li>
  <li>Python API: new system integration utilities, such as calibration (klampt.model.calibrate) and workspace calculation (klampt.model.workspace).</li>
  <li>C++ API: Everything added to the Klampt namespace. (API-breaking change!)</li>
  <li>C++ API: Main modeling classes renamed to align with Python API, e.g. Robot->RobotModel, RobotWorld->WorldModel, WorldSimulation->Simulator, etc. (API-breaking change!)</li>
  <li>Some geometries support slicing and ROI (region of interest) calculations. Slicing takes a slice of a geometry with a plane, and ROI calculations determine a region of interest of the geometry. Meshes and point clouds are supported.</li>
  <li>Other bug fixes and enhancements (see release notes in <a href="https://github.com/krishauser/klampt/">README</a>)</li>
</ul>
<p>Version 0.9.1:</p>
<ul>
  <li>Removed GLUI dependency in default build mode.</li>
  <li>Updated GLEW to 2.1.0.</li>
  <li>Builds for Linux Python 3.10+ are now working again. (Mac OS 11+ support is still TBD.)</li>
  <li>IK solver now has a minimization mode and a prioritized solve mode.</li>
  <li>Fixed bug in simulation of affine joints when the joint angle can go negative. Also, internal affine transmission coupling is simulated in a fashion that's sensitive to the driver's PID constants.</li>
  <li>Minor performance improvements to IK; API for getting subset of Jacobian columns.</li>
  <li>Python API: substantial performance improvements to camera image retrieval (camera_to_images).</li>
  <li>Python API: new calls for getting subset of Jacobian columns.</li>
  <li>Python API: Added types.convert generic utility function.</li>
  <li>Python API: Fixed bugs with vis module picker. Also, appearances can now have a tint set to match the C++ API.</li>
  <li>Python API: Bug fixes and type hints in coordinates module.</li>
  <li>Python API: Bug fix with cost evaluation in EmbeddedCSpace working on the embedded vectors (e.g., causing problems with outputs from makePlan)</li>
  <li>Python API: Removed klampt_path app and added functionality to klampt_resource app instead.</li>
</ul>
<p>Version 0.9.2:</p>
<ul>
	<li>Python API: pip packages now built with Numpy 2+.</li>
	<li>Python API: Improved calibration routines in `klampt.model.calibrate`.</li>
	<li>Python API: Added surface sampling and vertex normals to `klampt.model.geometry`.</li>
	<li>Python API: Added visibility fraction determination to `klampt.model.sensing`.</li>
	<li>Python API: Added conversions of meshes to/from the ``trimesh`` library in `klampt.io.trimesh_convert`.</li>
	<li>Python API: Fixed bug in SO3/SE3 Hermite velocity interpolation.  Now using extrinsic angular velocity representation as tangent vectors.</li>
	<li>Python API: Mouse wheel events can now be captured in visualization (Qt and GLUT backends).</li>
</ul>

<div class="separator"></div>

<a name="media"></a>
<h3> Media </h3>

<div class="video">
<p>Klamp't uses a robust contact generation scheme for mesh-mesh contact</p>
<!-- <iframe width="420" height="315" src="http://www.youtube.com/embed/WyqU56Pr5pg" frameborder="0" allowfullscreen></iframe> -->
<iframe  width="420" height="315"  src="https://drive.google.com/file/d/1S6r3-qfc-PXz4eQEYe5CrPjNqmw57LTI/preview"  frameborder="0" allowfullscreen></iframe>
</div>

<div class="video">
<p>Wheel turning on the PR2.  Motion courtesy of Dmitry Berenson at WPI. Compare with <a href="http://youtu.be/xRcUO2mXt3s">the real robot</a>.</p>
<!-- <iframe width="420" height="315" src="http://www.youtube.com/embed/UEW9z7lQ3Xc" frameborder="0" allowfullscreen></iframe> -->
<iframe width="420" height="315" src="https://drive.google.com/file/d/1MsP9dZDB5VWToTqJswTeyp4cCID8_SfD/preview" frameborder="0" allowfullscreen></iframe>
</div>

<div class="video">
<p>Staubli TX90 throwing a block</p>
<!-- <iframe width="420" height="315" src="http://www.youtube.com/embed/AuvGMUg9P4U" frameborder="0" allowfullscreen></iframe> -->
<iframe width="420" height="315" src="https://drive.google.com/file/d/11Gl7xC3awwBLW6QaCNwzUqKKFXN9W6CP/preview" frameborder="0" allowfullscreen></iframe>
</div>

<div class="video">
<p>Hubo-II+ walking on flat ground</p>
<!-- <iframe width="420" height="315" src="http://www.youtube.com/embed/tPQK5nHpRnQ" frameborder="0" allowfullscreen></iframe> -->
<iframe width="420" height="315" src="https://drive.google.com/file/d/1KEVwbG9CG-cZpcqCvMOM43GF1GugFRFA/preview" frameborder="0" allowfullscreen></iframe>
</div>

<div class="video">
<p>Hubo-II+ being tipped over on uneven ground</p>
<!-- <iframe width="420" height="315" src="http://www.youtube.com/embed/gpqm5K2P7uE" frameborder="0" allowfullscreen></iframe> -->
<iframe width="420" height="315" src="https://drive.google.com/file/d/1cRWjfiSpRu1GXmlhoua5ye2I2pfgyDSV/preview" frameborder="0" allowfullscreen></iframe>
</div>

<div class="video">
<p>Hubo-II+ climbing a ladder</p>
<!-- <iframe width="420" height="315" src="http://www.youtube.com/embed/Pou2NMeSZDc" frameborder="0" allowfullscreen></iframe> -->
<iframe width="420" height="315" src="https://drive.google.com/file/d/1tg0Oq_l1wuatwO3F_RumhAjUkx37dljO/preview" frameborder="0" allowfullscreen></iframe>
</div>

<div class="video" style="width:560px">
<p>Hubo-II+ switching feet, demonstrating force-torque sensing capabilities. Motion courtesy of Andy Park at Purdue University</p>
<!-- <iframe width="560" height="315" src="http://www.youtube.com/embed/79gNUOtGXM0" frameborder="0" allowfullscreen></iframe> -->
<iframe width="560" height="315" src="https://drive.google.com/file/d/1DAizdOdEeEvzg_RNaY8cT9mFeR_my6Of/preview" frameborder="0" allowfullscreen></iframe>
</div>

<div class="video">
<p>Comparison of Klampt's contact generation method against the GIMPACT method used in ODE / Bullet</p>
<!-- <iframe width="420" height="315" src="http://www.youtube.com/embed/tKAB1NRR8dY" frameborder="0" allowfullscreen></iframe> -->
<video width="420"  height="315" controls poster="https://i.ytimg.com/vi/tKAB1NRR8dY/hqdefault.jpg"
<source src="https://drive.google.com/uc?export=preview&id=1qARxK1ZQGCbQVJYr8ijdNi16oa7nhQeT" type="video/mp4">
</video>
</div>


<div class="separator"></div>

<h3>Downloading and Installing Klamp't</h3>
<a name="install"></a>
<p><b>Building from source</b></p>
  
  <p>Quick start (Python API only)</p>
    <ul>
        <li>pip install klampt</li>
        <li>(optional) git clone https://github.com/krishauser/Klampt-examples</li>
    </ul>

  <p>Complete-package installation tutorials are available for:</p>
    <ul>
    <li> <a href="https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Tutorials/Install-Linux.md">Linux</a></li>
    <li> <a href="https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Tutorials/Install-Windows.md">Windows</a></li>
    <li> <a href="https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Tutorials/Install-Mac.md">Mac OSX</a></li>
    <li> <a href="https://github.com/krishauser/Klampt/blob/master/Jupyter/README.md">Jupyter notebook</a></li>
    <li> <a href="https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Tutorials/Install-Docker.md">Docker</a></li>
    </ul>

<p><b>Precompiled binaries</b></p>
<p>Windows (32 bit) (up to date as of 12/1/2023).  You must also install the x86 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=48145">Visual Studio 2015 Runtime</a>.</p>
<ul>
<li><a href="http://motion.cs.illinois.edu/software/klampt/0.9/Klampt-0.9.1-win32.msi">Win32 Klamp't applications, static library (VS 2015 build) and C++ headers.</a> </li>
</ul>
<p>To compile your own C++ programs under Windows, you will need to 1) clone Klampt and KrisLibrary from git, then 3) unpack the correct precompiled dependency libraries to the Klampt/Library folder:</p>
<ul>
<li><a href="http://motion.cs.illinois.edu/software/klampt/0.9/Klampt-0.9.1.win32-deps-vs2015d.zip">Win32 dependency libraries, Visual Studio 2015, Debug build</a> </li>
<li><a href="http://motion.cs.illinois.edu/software/klampt/0.9/Klampt-0.9.1.win32-deps-vs2015.zip">Win32 dependency libraries, Visual Studio 2015, Release build</a> </li>
<li><a href="http://motion.cs.illinois.edu/software/klampt/0.9/Klampt-0.9.1.win64-deps-vs2015d.zip">x64 dependency libraries, Visual Studio 2015, Debug build</a> </li>
<li><a href="http://motion.cs.illinois.edu/software/klampt/0.9/Klampt-0.9.1.win64-deps-vs2015.zip">x64 dependency libraries, Visual Studio 2015, Release build</a> </li>
</ul>

<div class="separator"></div>

<h3>Documentation</h3>
<a name="docs"></a>
<ul>
  <li> <a href="http://motion.cs.illinois.edu/software/klampt/latest/pyklampt_docs">Klamp't Python Manual and API Documentation</a> </li>
  <li> <a href="https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Manual.md">Klamp't C++ Manual</a> </li>
  <li> <a href="http://motion.cs.illinois.edu/software/klampt/latest/klampt_docs">Klamp't C++ API</a> </li>
  <li> <a href="http://motion.cs.illinois.edu/software/krislibrary/krislibrary_docs">KrisLibrary C++ API</a> </li>
</ul>

<div class="separator"></div>

<h3>Frequently Asked Questions</h3>
<a name="faq"></a>
<ol>
  <li>
	<a class="Q" href="#" onclick="showHide('A_compare'); return false;">
	How does Klamp't compare to other simulators / programming environments (like ROS, RAVE, Webots, etc)?
	</a>
     <div class="A" id="A_compare">
	<p>The short answer: Klamp't is an all-in-one toolbox that specializes in robots with contact.</p>
      <p>Unlike ROS, Klamp't is not an architecture for sensing and control on distributed hardware.  Klamp't provides tools for modeling, planning, and simulation of robots with contact that are intended primarily for research and rapid prototyping. Klamp't comes with ROS bindings for its simulator and for reading point clouds.  Klamp't is more cross-platform and lighter weight.</p>
      <p>OpenRAVE is a similar library developed at CMU concurrently with Klamp't, but with a stronger focus on manipulation problems.  OpenRAVE does not support legged robots.  Moreover, simulation in OpenRAVE is often conflated with modeling and planning, whereas in Klamp't they are fully decoupled. </p>
      <p>Klamp't differs from other robot simulators (e.g., Gazebo, Webots, V-REP) because it has better collision handling that lets it handle complex contact phenomena between unstructured meshes and even point clouds.  Other simulators typically require a robot and its environment to be composed of simple geometric primitives or convex polyhedra, while Klamp't works well with polygon soup or point clouds directly from a CAD program or a depth scanner.  Other simulators typically have better visualizations and sensor simulation capabilities.  Klamp't ignores the bells and whistles and focuses on stable, robust contact.</p>
	</div>
  </li>
  <li>
	<a class="Q" href="#" onclick="showHide('A_start'); return false;">
	I'm a robotics newbie, where should I start?
	</a>
	<div class="A" id="A_start">
	<p>Most beginners should start learning the Python API and going through the examples in the manual.  Exercises from <a href="http://people.duke.edu/~kh269/teaching/b659/schedule.htm">an introductory graduate course on robotics</a> are provided in the Klampt-examples/Python/exercises folder. An open-source textbook, <a href="http://motion.cs.illinois.edu/RoboticSystems/">Robotic Systems</a> is being prepared, which will help you become more familiar with 3D transformations, configuration spaces, feedback control, and motion planning.</p>
	</div>
  </li>
    <li>
    <a class="Q" href="#" onclick="showHide('A_migrate0.9'); return false;">
    I was using 0.8.x, how do I migrate my code to 0.9?
    </a>
     <div class="A" id="A_migrate0.9">
    <p>C++:.</p>
	<ul>
		<li>Everything is now in the Klampt namespace, and classes match the corresponding Python classes.  So, Robot -> Klampt::RobotModel, RobotWorld -> Klampt::WorldModel, WorldSimulation->Klampt::Simulator, etc. </li>
	</ul>
    <p>Python:</p>
    <ul>
      <li>Module-level constants and functions have been renamed to conform to PEP8.  You will receive a DeprecationWarning when you try to use the old names (e.g., klampt.io.loader.typeToExtension -> klampt.io.loader.type_to_extension).  We are still using lowerCamelCase for class members to conform to historical usage.</li>
      <li>In the unlikely case that you were using the klampt.control package in 0.8.7, there are major changes that will require significant code rewrites.</li>
    </ul>
    </div>
  </li>
  <li>
	<a class="Q" href="#" onclick="showHide('A_import'); return false;">
	How do I import my robot?
	</a>
	<div class="A" id="A_import">
	<p>Klamp't reads from the <a href="http://wiki.ros.org/urdf">URDF</a> file format. It also uses a proprietary, simple ASCII format for defining robots (.rob files) which is much less verbose. </p> 
	<p>However, for simulation, Klamp't will need some special motor parameters (servoP, servoI, servoD, dryFriction, viscousFriction) that are not present in the URDF format.  We recommend that you 1) add the special klampt XML tag in the URDF, or 2 run the URDFtoRob program and then edit the generated parameters in the .rob file.  More details on this procedure can be found in the <a href="https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Manual-FileTypes.md#urdf-files-urdf-with-klampt-specific-elements">Klampt manual</a> and the <a href="https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Tutorials/Import-and-calibrate-urdf.md">robot import tutorial</a>.</p>
	<p> Some tips for successful URDF tagging and/or importing:</p>
	<ul>
		<li>URDF contains separate visualization / collision geometry per link while Klamp't only uses a single geometry.  To switch, toggle the useVisGeom setting in urdftorob.settings, or use_vis_geom attribute in the &lt;klampt&gt; URDF element.</li>
		<li>If imported meshes looks strange, try setting the flipYZ flag to true in urdftorob.settings, or the flip_yz attribute in the &lt;klampt&gt; URDF element.</li>
		<li>The mesh import/export paths can be set using urdftorob.settings or the package_root element in the &lt;klampt&gt; URDF element. </li>
		<li> To avoid converting geometry to the native .tri format, set outputGeometryExtension to the empty string ("") in urdftorob.settings.</li>
		<li>Dummy URDF links can safely be set to have 0 mass and inertia in the exported robot file.  Zero-mass dummy links will not affect the simulation as long as they are fixed to a link with mass.  You may also add the &lt;link name="[link name]" physical="0"/&gt; tag under the &lt;klampt&gt; element in the URDF file.</li>
		<li>For controller motion generation and trajectory optimization, it is <em>very important to set reasonable velocity and acceleration limits in the exported robot file</em>.</li>
		<li>SimTest allows you to tune joint PID constants and friction parameters during simulation by selecting "Window > Drivers" from the menu.</li>
		<li>Editing large .rob files is easiest in a spreadsheet program.</li>
	</ul>
	</div>
  </li>
  <li>
	<a class="Q" href="#" onclick="showHide('A_motor_constants'); return false;">
	How do I choose good motor constants for my robot simulation?
	</a>
      <div class="A" id="A_motor_constants"><p>This can be done by hand by tuning and "exercising" the robot in simulation.  The SimTest program has a window for tuning constants (Window > Drivers) while the simulation is running; a general strategy is to turn up damping or friction until the robot doesn't oscillate, and then turn up stiffness to track the setpoint about as well as your physical system does.  An automatic solution is given by the MotorCalibrate program, which will optimize the constants to match a dataset of sensed and commanded joint angles that you record while exercising the physical robot.  Please consult its documentation for more details, and you may run ./MotorCalibrate Examples/motorcalibrate_baxter.settings as an example.</p></div>
  </li>
  <li>
	<a class="Q" href="#" onclick="showHide('A_sim_faster'); return false;">
	How can I make the simulator faster?
	</a>
     <div class="A" id="A_sim_faster"><p> Simulation speed depends on several factors, including the number of rigid bodies, the complexity of the mesh geometry, and the complexity of contacting regions.  Small robots with simple meshes may be simulated in super-real-time, while complex robots with very complex meshes might be 100x slower than real-time.</p>
      <p>Usually, the bottleneck is contact generation and reponse, and its cost can be reduced by simplifying the mesh geometry using a 3D modeling program (e.g., Blender), or by reducing the value of the contact clustering parameter, maxContacts.<p>
     </div>
  </li>
  <li>
	<a class="Q" href="#" onclick="showHide('A_test_robot_controller'); return false;">
	How can I test my behavior code using a Klamp't simulation?
	</a>
     <div class="A" id="A_test_robot_controller">
	<p>Klamp't can be used for simulation testing of robot behaviors in a variety of ways.  There are two main steps: 1) tuning the simulation engine to match the real world as closely as possible, and 2) matching the interface between the behavior and simulated robot to the interface between the behavior and the real robot.</p>
	<p>Simulation tuning requires customizing the default rigid body simulator by setting up object models and surface parameters, and then adding forces, joints, etc. between objects in the world during the simulation loop. You may also add robot sensors to the simulation to imitate cameras, force sensors, etc. Klampt has a number of built-in sensor types, including RGB cameras, RGB-D cameras, laser rangefinders, force/torque sensors, IMUs, etc. If your robot uses more complex actuators and sensors, you must implement emulators for these items in the simulation loop.  Essentially, an emulator tries to duplicate the robot's motor controller software, actuator behavior, and sensors given complete access to the simulation state. </p> 
	<p>To match the interface between the behavior and the real robot, we provide the Robot Interface Layer in the Python API which is a unified interface to real and simulated robots.  You should write (or find) an RIL subclass for both the real and simulated robots such that they behave similarly when addressed using the klampt_control utility.  Simulation RILs for position-controlled and velocity-controlled robots are built-in to Klampt. See the <a href="http://motion.cs.illinois.edu/software/klampt/latest/pyklampt_docs/Manual-Control.html">control documentation</a> for more details</p>
    <p>To connect ROS behaviors to a Klamp't simulator, see klampt/control/blocks/io/roscontroller.py.  To connect Python behavior using Klampt's RIL to a ROS robot, use klampt/control/blocks/io/rosinterface.py.</p>
     </div>
  </li>
  <li>
	<a class="Q" href="#" onclick="showHide('A_connect_robot'); return false;">
	How can I use Klamp't planning tools on my robot?
	</a>
      <div class="A" id="A_connect_robot">
      <p>Klamp't planners and utilities must be incorporated into your robot's software environment via a bit of "glue code".</p>
      <p>For example, a behavior may invoke a Klamp't planner when it needs a new path.  The planner reads in the robot state and environment and uses Klamp't subroutines to generate a path.  Then it calls klampt.model.trajectory.execute_path given the Klamp't RIL controller for your robot. (Python API)  Paths are sent to your robot as piecewise linear or piecewise cubic curves if you have implemented the Robot Interface Layer of the Python API.  See the <a href="http://pythondocs.klampt.org/Manual-Control.html">control documentation</a> for more details</p>
      <p>Direct robot control in C++ can be achieved using a mechanism in Interface/UserInterface.h, employed in the UserTrials program. These interfaces read in user input, call a real-time planner, and then send the resulting path to a MotionQueueInterface object.  In UserTrials, the interface sends the path to a simulated robot.  But by overloading the MotionQueueInterface class with a custom subclass that communicates with your robot, you can control your robot directly.  (We have code available for Staubli 6DOF robots, please contact us if you are interested.)</p>
     </div>
  </li>

  <li>
    <a class="Q" href="#" onclick="showHide('A_bug_report'); return false;">
    I noticed a bug! How should I report it?
    </a>
    <div class="A" id="A_bug_report">
    <p>Please report the issue on the <a href="https://github.com/krishauser/Klampt/issues">Klampt Github Issues</a> page, and we'll get right on it.</p>
    </div>
  </li>

  <li>
	<a class="Q" href="#" onclick="showHide('A_get_help'); return false;">
	How should I get help using Klamp't?
	</a>
	<div class="A" id="A_get_help">
	<p>Please use the Klamp't forum at <a href="https://gitq.com/krishauser/Klampt">https://gitq.com/krishauser/Klampt</a>.</p>
	</div>
  </li>

  <li>
	<a class="Q" href="#" onclick="showHide('A_citing'); return false;">
	How should I acknowledge Klamp't in my publications?
	</a>
	<div class="A" id="A_citing">
	<p>For the Klamp't simulator, please cite K. Hauser. <a href="http://motion.cs.illinois.edu/papers/ISRR2013-RobustContact.pdf">Robust Contact Generation for Robot Simulation with Unstructured Meshes</a>. International Symposium on Robotics Research, December 2013. </p>
	<p>For the trajectory time-scaling subroutines, please cite K. Hauser. <a href="http://motion.cs.illinois.edu/papers/RSS2013_InterpolationOptimizationManifolds.pdf">Fast Interpolation and Time-Optimization on Implicit Contact Submanifolds</a>. In proceedings of Robotics: Science and Systems (RSS), Berlin, Germany, June 2013. </p>
	<p>For general usage, please cite the <a href="http://motion.cs.illinois.edu/software/klampt/latest/pyklampt_docs">Klamp't Manual</a>.</p>
	</div>
  </li>

<ol>
